## Rosetta Stone code
## Traditional binary is not optimum
# num_strings <- sapply(0:15, \(x) paste(rev(as.numeric(intToBits(x)))[-(1:28)], collapse=""))

## Instead, let's use Gray encoding
.Gray_strings <- c('0000', '0001', '0011', '0010',
                   '0110', '0111', '0101', '0100',
                   '1100', '1101', '1111', '1110',
                   '1010', '1011', '1001', '1000')


## TODO: Characters & Factors
## TODO: Allow variable length encoding, instead of 4 bits always
#' Transforms numerical columns of a dataframe into RLCS compatible binary strings
#'
#' Transforms Numeric Columns each into 16 buckets, binary-encoded with Gray encoding.
#' THIS IS CURRENTLY Work In Progress and should not be used aside from the Iris example.
#'
#' @param input_df A dataframe with numeric or integers columns, and a "class" column
#' @param class_col The "class" column which is not to be transformed
#'
#' @returns a list with a vector of cut values per column, column names and assigned values per entry, per column
#' @export
#'
#' @examples
#' rlcs_iris <- rlcs_rosetta_stone(iris, class_col=5) ## NOT part of the LCS Algorithm!
#' head(rlcs_iris$model, n=3)
rlcs_rosetta_stone <- function(input_df, class_col=1) {
  quartiles_slicer_cuts <- function(input_vec, nbits = 2) {

    t_summary <- as.numeric(summary(input_vec)[c(2, 3, 5)])

    summary_16 <- c()

    t_vec <- input_vec[which(input_vec < t_summary[1])]
    summary_16 <- c(summary_16, as.numeric(summary(t_vec)[c(2,3,5)]))
    summary_16 <- c(summary_16, t_summary[1])
    t_vec <- input_vec[which(input_vec >= t_summary[1])]
    t_vec <- t_vec[which(t_vec < t_summary[2])]
    summary_16 <- c(summary_16, as.numeric(summary(t_vec)[c(2,3,5)]))
    summary_16 <- c(summary_16, t_summary[2])
    t_vec <- input_vec[which(input_vec >= t_summary[2])]
    t_vec <- t_vec[which(t_vec < t_summary[3])]
    summary_16 <- c(summary_16, as.numeric(summary(t_vec)[c(2,3,5)]))
    summary_16 <- c(summary_16, t_summary[3])
    t_vec <- input_vec[which(input_vec >= t_summary[3])]
    summary_16 <- c(summary_16, as.numeric(summary(t_vec)[c(2,3,5)]))
    return(summary_16)
  }

  quartiles_slicer_vals <- function(input_vec, summary_16) {

    sapply(input_vec, \(x) {
      new_val <- '0000'
      for(i in 1:length(summary_16)) {
        if(x >= summary_16[i]) new_val <- RLCS:::.Gray_strings[i+1]
      }
      return(new_val)
    })
  }

  t_res <- list()
  for(t_col in 1:ncol(input_df)[-class_col]) {
    x <- input_df[,t_col]
    if(class(x) == "numeric" || class(x) == "integer") {
      if(length(unique(x)) < 16) stop("Current implementation of Rosetta Stone requires 16+ unique values per column")
      t_cuts <- quartiles_slicer_cuts(input_df[, t_col])
      t_vals <- quartiles_slicer_vals(input_df[, t_col], t_cuts)
      t_name <- names(input_df)[t_col]
      t_name <- paste0("rlcs_", t_name)
      t_res[[length(t_res)+1]] <- list(cuts=t_cuts, vals=t_vals, name=t_name)
    }
  }

  output_df <- data.frame(lapply(t_res,\(x) x$vals))
  names(output_df) <- lapply(t_res,\(x) x$name)

  output_df$class <- as.character(input_df[, class_col])

  output_df$state <- sapply(1:nrow(output_df), \(i) {
    state_val <- paste(output_df[i, which(names(output_df) != "class")], collapse="")
    state_val
  })
  list(cuts=lapply(t_res, \(x) x$cuts),
       var_names = names(output_df)[grepl("^rlcs_.*$", names(output_df))],
       model=output_df)
}


#' To facilitate reading a rule in a decoded format.
#'
#' Rosetta Stone encodes numerical data into binary strings for compatibility
#' with RLCS. This helper function helps decode the generated model.
#'
#' @param rule A rule from an RLCS model
#' @param rosetta_stone_obj A list previously generated by rlcs_rosetta_stone()
#'
#' @export
#'
rlcs_rosetta_decode_rule <- function(rule, rosetta_stone_obj) {
  rule_cond <- rule$condition_string
  print(paste("Rule Condition String:", rule_cond))

  print(.Gray_strings)

  tnbits <- 4
  tncols <- nchar(rule_cond)/tnbits
  tbits <- strsplit(rule_cond, "")[[1]]
  for(i in 1:tncols) {
    print("****")
    print(paste(rosetta_stone_obj$var_names[i], ":", paste(tbits[(4*(i-1)+1):(4*i)], collapse="")))

    t_cuts <- rosetta_stone_obj$cuts[[i]]
    tbits_tcol <- tbits[(4*(i-1)+1):(4*i)]
    candidates <- RLCS:::.Gray_strings
    candidates_pos <- 1:length(candidates)
    # browser()
    for(j in 1:tnbits) {
      if(tbits_tcol[j] == 1) {
        candidates_pos <- candidates_pos[which(sapply(candidates, \(x) {
          strsplit(x, "")[[1]][j] == 1
        }))]
        candidates <- candidates[which(sapply(candidates, \(x) {
          strsplit(x, "")[[1]][j] == 1
        }))]

      }
      if(tbits_tcol[j] == 0) {
        candidates_pos <- candidates_pos[which(sapply(candidates, \(x) {
          strsplit(x, "")[[1]][j] == 0
        }))]
        candidates <- candidates[which(sapply(candidates, \(x) {
          strsplit(x, "")[[1]][j] == 0
        }))]

      }

    }

    if(length(candidates) == 16) {
      print(paste(rosetta_stone_obj$var_names[i], "can take any value"))
    } else {
      print("Cuts")
      print(rosetta_stone_obj$cuts[[i]])
      print(candidates_pos)

      sapply(candidates_pos, \(x) {
        if(x == 1) print(paste(rosetta_stone_obj$var_names[i], "less than", t_cuts[1]))
        if(x == 16) print(paste(rosetta_stone_obj$var_names[i], "greater than", t_cuts[15]))
        if(1 < x && x < 16) print(paste(rosetta_stone_obj$var_names[i], "between", t_cuts[x-1], "and", t_cuts[x]))
      })
    }

  }
}
